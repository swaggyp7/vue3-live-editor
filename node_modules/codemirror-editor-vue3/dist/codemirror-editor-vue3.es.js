var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import "codemirror/lib/codemirror.css";
import { defineComponent, ref, onMounted, markRaw, watch, openBlock, createElementBlock, nextTick, getCurrentInstance, onBeforeUnmount, normalizeClass, normalizeStyle, createBlock, resolveDynamicComponent, mergeProps } from "vue";
import _CodeMirror from "codemirror";
import "codemirror/addon/merge/merge.css";
import "codemirror/addon/merge/merge.js";
import DiffMatchPatch from "diff-match-patch";
import "codemirror/addon/mode/simple.js";
import * as codemirror from "codemirror/lib/codemirror.js";
var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const CodeMirror$2 = window.CodeMirror || _CodeMirror;
const _sfc_main$3 = defineComponent({
  name: "defaultMode",
  props: {
    name: {
      type: String,
      default: `cm-textarea-${+new Date()}`
    },
    value: String,
    content: String,
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(props, { emit }) {
    const textarea = ref();
    const _cminstance = ref(null);
    const initialize = () => {
      _cminstance.value = markRaw(CodeMirror$2.fromTextArea(textarea.value, props.options));
      emit("update:cminstance", _cminstance.value);
      let unwatch = null;
      unwatch = watch(() => props.cminstance, (val, oldVal) => {
        val && props.cminstance.setValue(props.value || props.content);
        emit("ready", _cminstance);
        unwatch();
      }, { deep: true });
    };
    onMounted(() => {
      initialize();
    });
    return {
      initialize,
      textarea
    };
  }
});
const _hoisted_1$2 = ["name", "placeholder"];
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", {
    ref: "textarea",
    name: _ctx.$props.name,
    placeholder: _ctx.$props.placeholder
  }, null, 8, _hoisted_1$2);
}
var Default = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
const CodeMirror$1 = (window == null ? void 0 : window.CodeMirror) || _CodeMirror;
window.diff_match_patch = DiffMatchPatch;
window.DIFF_DELETE = -1;
window.DIFF_INSERT = 1;
window.DIFF_EQUAL = 0;
const _sfc_main$2 = defineComponent({
  name: "mergeMode",
  props: {
    name: {
      type: String,
      default: `cm-mergeView-${new Date().toString()}`
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(props, { emit }) {
    const _cminstance = ref(null);
    const mergeView = ref(null);
    const initialize = () => {
      _cminstance.value = markRaw(CodeMirror$1.MergeView(mergeView.value, props.options));
      emit("update:cminstance", _cminstance.value.edit);
      emit("ready", _cminstance);
    };
    onMounted(() => {
      initialize();
    });
    return {
      mergeView,
      initialize
    };
  }
});
const _hoisted_1$1 = ["name"];
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "mergeView",
    name: _ctx.$props.name
  }, null, 8, _hoisted_1$1);
}
var Merge = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
var errorType;
(function(errorType2) {
  errorType2["info"] = "info";
  errorType2["warning"] = "warning";
  errorType2["error"] = "error";
})(errorType || (errorType = {}));
function getLocalTime() {
  const date = new Date();
  const h = date.getHours() < 10 ? "0" + date.getHours() : date.getHours();
  const m = date.getMinutes() < 10 ? "0" + date.getMinutes() : date.getMinutes();
  const s = date.getSeconds() < 10 ? "0" + date.getSeconds() : date.getSeconds();
  return `${h}:${m}:${s}`;
}
function createLinkMark(attrs) {
  return `#link#${JSON.stringify(attrs)}#link#`;
}
function getLinkMark(value) {
  const linkRegexp = /#link#(.+)#link#/g;
  let result = [];
  let indexObj;
  indexObj = linkRegexp.exec(value);
  while (indexObj) {
    const node = document.createElement("a");
    const attrs = JSON.parse(indexObj[1]);
    const keyAndValues = Object.entries(attrs);
    for (let [_key, _value] of keyAndValues) {
      node.setAttribute(_key, _value);
    }
    node.className = "editor_custom_link";
    node.innerHTML = "logDownload";
    result.push({
      start: indexObj.index,
      end: indexObj.index + indexObj[0].length,
      node
    });
    indexObj = linkRegexp.exec(value);
  }
  return result;
}
function createLogMark(text = "", type = "info") {
  return `#log<${type}>log#${text}#log<${type}>log#`;
}
function getLogMark(value) {
  let result = [];
  function match() {
    const logRegexp = new RegExp(`#log<(\\w*)>log#((.|\r
|
)*?)#log<(\\w*)>log#`, "g");
    let indexObj;
    indexObj = logRegexp.exec(value);
    while (indexObj) {
      let text = indexObj[0].replace(/\r\n/g, "\n");
      let textArr = text.split("\n");
      let content = indexObj[2].replace(/\r\n/g, "\n");
      let contentArr = content.split("\n");
      const node = document.createElement("span");
      let type = indexObj[1];
      node.className = `c-editor--log__${type}`;
      let offset = 0;
      for (let i = 0; i < textArr.length; i++) {
        let textItem = textArr[i];
        let contentItem = contentArr[i];
        let cloneNode = node.cloneNode(false);
        cloneNode.innerText = contentItem;
        result.push({
          start: indexObj.index + offset,
          end: indexObj.index + offset + textItem.length,
          node: cloneNode
        });
        offset = offset + textItem.length + 1;
      }
      indexObj = logRegexp.exec(value);
    }
  }
  match();
  return result;
}
function createLog(log, type = "") {
  let now = getLocalTime();
  return `[${now}] <${type}> ${log}`;
}
function createTitle(title = "", baseLength = 20, symbol = "=") {
  const offsetLength = Math.floor(1.5 * title.length / 2);
  let arr = new Array(Math.max(baseLength - offsetLength, 5));
  const wraptext = arr.join(symbol);
  return `${wraptext}${title}${wraptext}`;
}
const startRegex = [
  {
    regex: /(\[.*?\])([ \t]*)(<error>[ \t])(.+)/,
    token: ["tag", null, "error.strong", "error.strong"],
    sol: true
  },
  {
    regex: /(\[.*?\])([ \t]*)(<info>)(.+)(.?)/,
    token: ["tag", null, "bracket", "bracket", "hr"],
    sol: true
  },
  {
    regex: /(\[.*?\])([ \t]*)(<warning>)(.+)(.?)/,
    token: ["tag", null, "comment", "comment", "hr"],
    sol: true
  }
];
_CodeMirror.defineSimpleMode("fclog", {
  start: [
    ...startRegex,
    {
      regex: /.*/,
      token: "hr"
    }
  ],
  error: [
    ...startRegex,
    {
      regex: /.*/,
      token: "error.strong"
    }
  ],
  info: [
    ...startRegex,
    {
      regex: /.*/,
      token: "bracket"
    }
  ],
  warning: [
    ...startRegex,
    {
      regex: /.*\[/,
      token: "comment"
    }
  ]
});
codemirror.defineSimpleMode("log", {
  start: [
    {
      regex: /^[=]+[^=]*[=]+/,
      token: "strong"
    },
    {
      regex: /([^\w])([A-Z][\w]*)/,
      token: [null, "string"]
    },
    {
      regex: /(^[A-Z][\w]*)/,
      token: "string"
    }
  ]
});
const CodeMirror = window.CodeMirror || _CodeMirror;
const _sfc_main$1 = defineComponent({
  name: "codemirror-fclog",
  props: {
    value: String,
    content: String,
    name: {
      type: String,
      default: `cm-textarea-${+new Date()}`
    },
    options: {
      type: Object,
      default: () => ({})
    },
    cminstance: {
      type: Object,
      default: () => ({})
    },
    placeholder: {
      type: String,
      default: ""
    }
  },
  emits: ["update:cminstance", "ready"],
  setup(props, { emit }) {
    const textarea = ref();
    const _cminstance = ref(null);
    const renderTextMark = (cminstance = props.cminstance) => {
      const marks = cminstance.getAllMarks();
      marks.forEach((mark) => mark.clear());
      const value = cminstance.getValue();
      const linkMarks = [].concat(getLinkMark(value)).concat(getLogMark(value));
      for (let _i = 0; _i < linkMarks.length; _i++) {
        const mark = linkMarks[_i];
        cminstance.markText(cminstance.posFromIndex(mark.start), cminstance.posFromIndex(mark.end), { replacedWith: mark.node });
      }
    };
    const initialize = () => {
      _cminstance.value = markRaw(CodeMirror.fromTextArea(textarea.value, props.options));
      emit("update:cminstance", markRaw(_cminstance.value));
      _cminstance.value.on("change", renderTextMark);
    };
    watch(() => props.cminstance, (val) => {
      if (val) {
        renderTextMark(props.cminstance);
        props.cminstance.setValue(props.value || props.content);
        emit("ready", _cminstance);
      }
    }, { deep: true, immediate: true });
    onMounted(() => {
      initialize();
    });
    return {
      initialize,
      textarea
    };
  }
});
const _hoisted_1 = ["name", "placeholder"];
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("textarea", {
    ref: "textarea",
    name: _ctx.$props.name,
    placeholder: _ctx.$props.placeholder
  }, null, 8, _hoisted_1);
}
var FcLog = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
function scrollToEnd(cm) {
  Promise.resolve().then(() => {
    let nowScrollInfo = cm.getScrollInfo();
    cm.scrollTo(nowScrollInfo.left, nowScrollInfo.height);
  });
}
function useEvents({
  props,
  cminstance,
  ctx,
  internalInstance,
  content,
  componentsEvts: componentsEvts2
}) {
  const getUseEvents = () => {
    let evts = [];
    Object.keys(internalInstance.vnode.props).forEach((v) => {
      if (v.startsWith("on")) {
        let e = v.replace(v[2], v[2].toLowerCase()).slice(2);
        !componentsEvts2.includes(e) && evts.push(e);
      }
    });
    return evts;
  };
  const listenerEvents = () => {
    cminstance.value.on("change", (cm) => {
      const currentVal = cm.getValue();
      if (currentVal == content.value)
        return;
      content.value = currentVal;
      ctx.emit("update:value", content.value);
      ctx.emit("input", content.value);
      Promise.resolve().then(() => {
        ctx.emit("change", content.value, cm);
      });
      props.KeepCursorInEnd && scrollToEnd(cm);
    });
    const tmpEvents = {};
    const useEvts = getUseEvents();
    const allEvents = useEvts.filter((e) => !tmpEvents[e] && (tmpEvents[e] = true)).forEach((event) => {
      cminstance.value.on(event, (...args) => {
        ctx.emit(event, ...args);
      });
    });
    return allEvents;
  };
  return {
    listenerEvents
  };
}
function useViewControl({ props, cminstance, presetRef }) {
  const containerWidth = ref(null);
  const containerHeight = ref(null);
  const refresh = () => {
    nextTick(() => {
      cminstance.value.refresh();
    });
  };
  const resize = (width = props.width, height = props.height) => {
    containerWidth.value = String(width).replace("px", "");
    containerHeight.value = String(height).replace("px", "");
    let cmHeight = containerHeight.value;
    cminstance.value.setSize(containerWidth.value, cmHeight);
  };
  const destroy = () => {
    const element = cminstance.value.doc.cm.getWrapperElement();
    element == null ? void 0 : element.remove();
  };
  const isStyleChaotic = () => {
    const gutterEl = document.querySelector(".CodeMirror-gutters");
    const gutterElLeft = gutterEl.style.left.replace("px", "");
    return gutterElLeft != "0";
  };
  const reviseStyle = () => {
    refresh();
    if (!isStyleChaotic())
      return;
    let timer = setInterval(() => {
      isStyleChaotic() ? refresh() : clearInterval(timer);
    }, 60);
    let clearTimer = setTimeout(() => {
      clearInterval(timer);
      clearTimeout(clearTimer);
      timer = null;
      clearTimer = null;
    }, 400);
  };
  return {
    refresh,
    resize,
    destroy,
    containerHeight,
    reviseStyle
  };
}
const componentsEvts = ["update:value", "change", "input", "ready"];
const cmEvts = [
  "changes",
  "scroll",
  "beforeChange",
  "cursorActivity",
  "keyHandled",
  "inputRead",
  "electricInput",
  "beforeSelectionChange",
  "viewportChange",
  "swapDoc",
  "gutterClick",
  "gutterContextMenu",
  "focus",
  "blur",
  "refresh",
  "optionChange",
  "scrollCursorIntoView",
  "update"
];
const DEFAULT_OPTIONS = {
  mode: "text",
  theme: "default",
  lineNumbers: true,
  smartIndent: true,
  indentUnit: 2,
  foldGutter: true,
  matchBrackets: true,
  autoCloseBrackets: true,
  styleActiveLine: true
};
if (typeof Object.assign != "function") {
  Object.defineProperty(Object, "assign", {
    value(target, varArgs) {
      if (target == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      const to = Object(target);
      for (let index2 = 1; index2 < arguments.length; index2++) {
        const nextSource = arguments[index2];
        if (nextSource != null) {
          for (const nextKey in nextSource) {
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
const _sfc_main = defineComponent({
  name: "CodemirrorEditor",
  props: {
    value: String,
    marker: Function,
    unseenLines: Array,
    name: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: ""
    },
    merge: {
      type: Boolean,
      default: false
    },
    options: {
      type: Object,
      default: () => ({})
    },
    globalOptions: {
      type: Object,
      default: () => ({})
    },
    border: {
      type: Boolean,
      default: false
    },
    width: {
      type: [String, Number],
      default: null
    },
    height: {
      type: [String, Number],
      default: null
    },
    KeepCursorInEnd: {
      type: Boolean,
      default: false
    }
  },
  emits: [...componentsEvts, ...cmEvts],
  components: {
    Default,
    Merge,
    FcLog
  },
  setup(props, ctx) {
    var _a, _b;
    const cminstance = ref(null);
    const content = ref("");
    const presetModeName = ref("Default");
    const cmOptions = ref(Object.assign(__spreadValues({}, DEFAULT_OPTIONS), props.globalOptions, props.options));
    const internalInstance = getCurrentInstance();
    const presetRef = ref(null);
    const { refresh, resize, destroy, containerHeight, reviseStyle } = useViewControl({
      props,
      cminstance,
      presetRef
    });
    const { listenerEvents } = useEvents({
      props,
      cminstance,
      ctx,
      internalInstance,
      content,
      componentsEvts
    });
    const unseenLineMarkers = () => {
      if (props.unseenLines !== void 0 && props.marker !== void 0) {
        props.unseenLines.forEach((line) => {
          const info = cminstance.value.lineInfo(line);
          cminstance.value.setGutterMarker(line, "breakpoints", info.gutterMarkers ? null : props.marker());
        });
      }
    };
    const onCodeChange = (newVal) => {
      const cm_value = cminstance.value.getValue();
      if (newVal !== cm_value) {
        cminstance.value.setValue(newVal);
        content.value = newVal;
        reviseStyle();
      }
      unseenLineMarkers();
    };
    const ready = (codemirror2) => {
      listenerEvents();
      unseenLineMarkers();
      resize();
      ctx.emit("ready", cminstance.value);
      watch([() => props.height, () => props.width], ([height, width]) => {
        resize(height, width);
      }, { deep: true });
    };
    const handlePresetModeName = () => {
      if (props.options.mode == "fclog" || props.options.mode == "log") {
        presetModeName.value = "FcLog";
        return;
      }
      if (props.merge) {
        presetModeName.value = "Merge";
        return;
      }
      presetModeName.value = "default";
    };
    watch(() => props.options, (val) => {
      for (const key in props.options) {
        cminstance.value.setOption(key, val[key]);
      }
    }, { deep: true });
    watch(() => props.value, (val) => {
      onCodeChange(val);
    });
    watch(() => props.merge, (val) => {
      handlePresetModeName();
    }, { immediate: true });
    onBeforeUnmount(() => {
      destroy();
    });
    return {
      presetModeName,
      cmOptions,
      cminstance,
      content,
      ready,
      resize,
      containerHeight,
      instanceName: props.name || ((_b = (_a = internalInstance == null ? void 0 : internalInstance.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.name) || void 0,
      presetRef
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["codemirror-container", {
      merge: _ctx.$props.merge,
      bordered: _ctx.$props.border || _ctx.$props.merge,
      "width-auto": !_ctx.$props.width || _ctx.$props.width == "100%",
      "height-auto": !_ctx.$props.height || _ctx.$props.height == "100%"
    }]),
    style: normalizeStyle({
      height: _ctx.containerHeight + "px"
    })
  }, [
    (openBlock(), createBlock(resolveDynamicComponent(_ctx.presetModeName), mergeProps({
      style: { "height": "100%" },
      ref: "presetRef",
      cminstance: _ctx.cminstance,
      "onUpdate:cminstance": _cache[0] || (_cache[0] = ($event) => _ctx.cminstance = $event)
    }, __spreadProps(__spreadValues(__spreadValues({}, _ctx.$props), _ctx.$attrs), {
      options: _ctx.cmOptions,
      name: _ctx.instanceName,
      content: _ctx.content
    }), { onReady: _ctx.ready }), null, 16, ["cminstance", "onReady"]))
  ], 6);
}
var Codemirror = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
var index$1 = "";
var index = "";
Codemirror.install = (app, config) => {
  if (config) {
    if (config.options) {
      Codemirror.props.globalOptions.default = () => config.options;
    }
    if (config.events) {
      Codemirror.props.globalEvents.default = () => config.events;
    }
  }
  app.component("Codemirror", Codemirror);
  return app;
};
function styleInject(css,ref){if(ref===void 0){ref={}}var insertAt=ref.insertAt;if(!css||typeof document==="undefined"){return}var head=document.head||document.getElementsByTagName("head")[0];var style=document.createElement("style");style.type="text/css";if(insertAt==="top"){if(head.firstChild){head.insertBefore(style,head.firstChild)}else{head.appendChild(style)}}else{head.appendChild(style)}if(style.styleSheet){style.styleSheet.cssText=css}else{style.appendChild(document.createTextNode(css))}};styleInject(`.codemirror-container {
  position: relative;
  display: inline-block;
  height: 100%;
  width: fit-content;
  font-size: 12px;
  overflow: hidden;
}
.codemirror-container.bordered {
  border-radius: 4px;
  border: 1px solid #dddddd;
}
.codemirror-container.width-auto {
  width: 100%;
}
.codemirror-container.height-auto {
  height: 100%;
}
.codemirror-container.height-auto .CodeMirror,
.codemirror-container.height-auto .cm-s-default {
  height: 100% !important;
}
.CodeMirror-lines .CodeMirror-placeholder.CodeMirror-line-like {
  color: #666;
}
.CodeMirror,
.CodeMirror-merge-pane {
  height: 100%;
  font-family: consolas !important;
}
.CodeMirror-merge,
.CodeMirror-merge-right .CodeMirror {
  height: 100%;
  border: none !important;
}
.editor_custom_link {
  cursor: pointer;
  color: #1474f1;
  text-decoration: underline;
}
.editor_custom_link:hover {
  color: #04b4fa;
}
.c-editor--log__error {
  color: #bb0606;
  font-weight: bold;
}
.c-editor--log__info {
  color: #333333;
  font-weight: bold;
}
.c-editor--log__warning {
  color: #ee9900;
}
.c-editor--log__success {
  color: #669600;
}
.cm-header,
.cm-strong {
  font-weight: bold;
}
`);
export { Codemirror, createLinkMark, createLog, createLogMark, createTitle, Codemirror as default, getLinkMark, getLocalTime, getLogMark };
